#!/bin/bash -e

function bump_version_file {
  case "$1" in
    patch|minor|major)
      bump=$1; shift
      set $(cat VERSION | sed 's#\.# #g')
      case "$bump" in
        patch)
          echo "$1.$2.$(($3 + 1))"
          ;;
        minor)
          echo "$1.$(($2 + 1)).0"
          ;;
        major)
          echo "$(($1 + 1)).0.0"
          ;;
      esac > VERSION
      ;;
    *)
      ver_new=$1; shift
      set $(echo "$ver_new" | sed 's#\.# #g') 0
      M=$1; shift
      m=$1; shift
      p=$1; shift

      tmp_version=$(mktemp -t XXXXXXXXX)
      (echo "$(($M+0)).$(($m+0)).$(($p+0))" > $tmp_version) 2>&-
      ver_new_same=$(cat $tmp_version)
      rm -f $tmp_version

      if [[ $ver_new = $ver_new_same ]]; then
        echo "$ver_new" > VERSION
      else
        echo "ERROR: invalid version: $ver_new" 1>&2
        exit 1
      fi
      ;;
  esac

  if [[ -f Gemfile ]]; then
    bundle check 2>&1 >/dev/null || { bundle --quiet install --local --path vendor/bundle || bundle check > /dev/null; }
    git add Gemfile.lock
  fi

  git add VERSION

  ver_bumped=$(cat VERSION)
  git commit -m "bump: $ver_bumped"
  git_tag "v$ver_bumped"
  git push
  echo $ver_bumped
}

function bump_version_tag {
  tmp_version=$(mktemp -t XXXXXXXXX)
  case "$1" in
    patch|minor|major)
      bump=$1; shift
      set $(cat tmp_version| sed 's#\.# #g')
      case "$bump" in
        patch)
          echo "$1.$2.$(($3 + 1))"
          ;;
        minor)
          echo "$1.$(($2 + 1)).0"
          ;;
        major)
          echo "$(($1 + 1)).0.0"
          ;;
      esac > $tmp_version
      ;;
    *)
      ver_new=$1; shift
      set $(echo "$ver_new" | sed 's#\.# #g') 0
      M=$1; shift
      m=$1; shift
      p=$1; shift

      tmp_version=$(mktemp -t XXXXXXXXX)
      (echo "$(($M+0)).$(($m+0)).$(($p+0))" > $tmp_version) 2>&-
      ver_new_same=$(cat $tmp_version)
      rm -f $tmp_version

      if [[ $ver_new = $ver_new_same ]]; then
        echo "$ver_new" > $tmp_version
      else
        echo "ERROR: invalid version: $ver_new" 1>&2
        exit 1
      fi
      ;;
  esac

  ver_bumped=$(cat $tmp_version)
  git_tag "v$ver_bumped"
  echo $ver_bumped
}

function git_tag {
  local version=$1; shift

  git fetch --tags
  remote_sha=$(git ls-remote origin $version | awk '{print $1}')
  if [[ -n $remote_sha ]]; then
    echo "ERROR: already a remote tag $version, bump again" 1>&2
    exit 1
  fi

  git tag $version
  git push origin tag $version
  remote_sha=$(git ls-remote origin $version | awk '{print $1}')
  local_sha=$(git show-ref $version | awk '{print $1}')
  if [[ $remote_sha != $local_sha ]]; then
    echo "ERROR: remote tag $version does not match local SHA" 1>&2
    exit 1
  fi
}

function ensure_clean_git_status {
  local lines=$(git status -s -uno | wc -l | awk '{print $1}')
  if [[ $lines != "0" ]]; then
    echo "ERROR: git status is not clean, cannot tag" 1>&2
    git status -s -uno
    exit 1
  fi
}

case "$(basename $0)" in
  bump)
    true
    ;;
  *)
    hst_this=$(hostname -s)
    if ! echo "$hst_this" | egrep -q "^(admin|develop)"; then
      # unless the .ao_no_proxy file exists
      if [[ ! -f ".ao_no_proxy" ]]; then
        # ssh into deploy host and run from there
        exec bin/proxy $(basename $0) "$@"
        exit 1
      fi
    fi
    ;;
esac

export LOCAL_ONLY=true

default_pod=$(cat /etc/podname 2>&- || true)

case "$(basename $0)" in
  invoke)
    export COMMAND="$1"; shift

    if [[ -n $1 ]]; then
      set $(for a in "$@"; do if [[ $default_pod = $a ]]; then echo "default.app"; else echo $a.app; fi; done)
    fi

    LOCAL_ONLY=
    tmp_invoke=$(mktemp -t XXXXXXXXX)
    bundle exec cap "$@" invoke 2>&1 | perl -pe 's{.\[\d+m}{}g' | perl -ne 'm{^\s*\*+\s*\[(out|err)\s*::\s*([^]]+)\] ?(.*)} && print "$1 $2 $3\n"' > $tmp_invoke 2>&1

    cat $tmp_invoke | awk '{print $2}' | sort -u | while read -r nm_host; do
      egrep "^(out|err) $nm_host" $tmp_invoke || true
      echo
    done
    rm -f $tmp_invoke
    ;;
  *)
    if [[ -n $1 ]]; then
      set $(for a in "$@"; do if [[ $default_pod = $a ]]; then echo "default"; else echo $a; fi; done)
    fi

    case "$(basename $0)" in
      debug)
        if [[ -z $1 ]]; then
          set "world"
        fi

        if [[ -n $1 ]]; then
          cap $(for a in "$@"; do echo $a.echo; done)
        fi
        ;;

      hosts)
        {
          if [[ -n $1 ]]; then
            cap $(for a in "$@"; do echo $a.echo; done)
          fi
        } 2>&1 | grep eea914aaa8dde6fdae29242b1084a2b0415eefaf | awk '{print $NF}' | sort -u
        ;;

      dna)
        {
          echo "eea914aaa8dde6fdae29242b1084a2b0415eefaf ---"
          if [[ -n $1 ]]; then
            cap $(for a in "$@"; do echo $a.yaml; done)
          fi
        } 2>&1 | grep eea914aaa8dde6fdae29242b1084a2b0415eefaf | sed 's#eea914aaa8dde6fdae29242b1084a2b0415eefaf ##'
        ;;

      bump)
        ensure_clean_git_status
        if [[ -f VERSION || -L VERSION ]]; then
          if [[ -e VERSION ]]; then
            bump_version_file "$@"
          else
            echo "ERROR: cannot write to VERSION file" 1>&2
            exit 1
          fi
        else
          bump_version_tag
        fi
        ;;

      *)
        LOCAL_ONLY=
        if [[ -n $1 ]]; then
          set $(for a in "$@"; do echo $a.app; done)
        fi
        case "$(basename $0)" in
          deploy)
            bundle exec cap "$@" deploy:lock deploy
            ;;

          release)
            bundle exec cap "$@" deploy:lock deploy
            ;;

          stage)
            bundle exec cap "$@" deploy:lock deploy:update_code deploy:symlink_next
            ;;

          restart)
            bundle exec cap "$@" deploy:lock deploy:restart
            ;;

          config)
            bundle exec cap "$@" deploy:lock deploy:config
            ;;

          build)
            bundle exec cap "$@" deploy:lock deploy:build
            ;;

          dist)
            bundle exec cap "$@" deploy:lock deploy:dist
            ;;

          activate)
            bundle exec cap "$@" deploy:lock deploy:symlink deploy:restart
            ;;

          rollback)
            bundle exec cap "$@" deploy:lock deploy:rollback
            ;;

          check)
            bundle exec cap "$@" deploy:lock deploy:check
            ;;

          plan)
            bundle exec cap "$@" deploy:lock deploy:plan
            ;;

          lock)
            bundle exec cap "$@" deploy:dont_unlock deploy:lock
            ;;

          unlock)
            bundle exec cap "$@" deploy:unlock
            ;;

          shell)
            bundle exec cap "$@" shell
            ;;

          compare)
            bundle exec cap "$@" deploy:compare
            ;;

          migrate)
            want_list=
            if [[ $1 = "list" ]]; then
              want_list=1; shift
            fi

            change_group=
            migration=
            case $1 in
              data)
                change_group=$1; shift
                ;;
              pre)
                change_group=$1; shift
                ;;
              during)
                change_group=$1; shift
                ;;
              post)
                change_group=$1; shift
                ;;
              [0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789][0123456789])
                migration=$1; shift
                ;;
            esac

            if [[ -n $change_group ]]; then
              if [[ -n $want_list ]]; then
                echo "listing change group $change_group"
              else
                echo "running change group $change_group"
              fi
            elif [[ -n $migration ]]; then
              echo "running migration $migratio"
            elif [[ -n $want_list ]]; then
              echo "listing migrations"
            fi
            #bundle exec cap "$@" deploy:migrate
            ;;

          *)
            bundle exec cap "$@"
            ;;
        esac
    esac
    ;;
esac

